# Fonctions sur les types (lang)

La section Lang de **Lodash** regroupe les fonctions dites utilitaires de langage.  
Elles ne transforment pas directement des cha√Ænes, des tableaux ou des objets, mais permettent de tester, comparer et convertir des types de donn√©es.
C‚Äôest un socle indispensable pour √©crire des transformations robustes et √©viter les quelques pi√®ges qui peuvent exister.  

---

Parmi celles-ci il existe plusieurs fonctions qui permettent de tester le type d'une valeur (*.isX*) et qui ont souvent leur pendant pour convertir une valeur dans un type donn√©e (*.toX*).  
Malheureusement il n'existe pas de fonction unique pour renvoyer le type de la valeur test√©e. Pour ce faire il faut utiliser une fonction **JavaScript**, `typeof` en l'occurence.

```js
value = get("value.entree").thru(valeur => typeof(valeur))
// Entr√©e : "texte" ‚Üí Sortie : "string"
// Entr√©e : true ‚Üí Sortie : "boolean"
// Entr√©e : 42 ‚Üí Sortie : "number"
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : "object"
// Entr√©e : [1, 2, 3] ‚Üí Sortie : "object"
// Entr√©e : null ‚Üí Sortie : "object"
```

> [!WARNING]
> On s'aper√ßoit que les trois derni√®res sorties sont *"object"* alors que l'on a bien un **objet**, mais aussi un **tableau** ainsi qu'un ***null***...  
> Ceci s'explique par le fait qu'**en JavaScript, un tableau est en r√©alit√© un objet particulier** dont les cl√©s sont des nombres (0, 1, 2, ‚Ä¶) servant d‚Äôindex.  
>  
> En JavaScript, ***null*** est une **valeur primitive** repr√©sentant l‚Äôabsence volontaire de valeur mais dont `typeof` renvoie pourtant *"object"*.  
>
> Il s‚Äôagit en fait d‚Äôun **bug historique** : dans les premi√®res versions du langage, les valeurs √©taient cod√©es avec des tags binaires en m√©moire. 
> Le tag 000 identifiait les objets, et la valeur ***null***, stock√©e comme 0x00 (adresse nulle, pour repr√©senter l‚Äôabsence de valeur), a √©t√© interpr√©t√©e √† tort comme un objet. 
> Ce bug n'a jamais √©t√© corrig√© afin de ne pas casser tout le code existant. Pour en savoir plus, vous pouvez aller [ici](https://2ality.com/2013/10/typeof-null.html), [l√†](https://262.ecma-international.org/5.1/#sec-11.4.3) ou [l√†](https://medium.com/%40AlexanderObregon/the-real-reason-javascript-typeof-null-returns-object-f41d39c9fe5b).  

> [!NOTE]  
> On pourrait √©galement objecter (üòÅ) qu'***undefined*** n'a pas √©t√© test√©. C'est parce qu'un JSON ne peut pas contenir directement ***undefined***, c'est un concept **JavaScript**.
> Pour ce faire il faut provoquer une erreur en acc√©dant √† une cl√© qui n'existe pas.
> ```js
> value = get("value.entreeQuiNexistePas").thru(valeur => typeof(valeur))
> // Entr√©e : 42 ‚Üí Sortie : "undefined"
> ```

üí° **Cependant** il est tout de m√™me possible de tester n'importe quelle valeur et d'en conna√Ætre le type "exact", mais il convient d'utiliser une fonction particuli√®re :

```js
value = get("value.entree").thru(valeur => Object.prototype.toString.call(valeur))
// Entr√©e : 42 ‚Üí Sortie : "[object Number]"
```

Le r√©sultat de la fonction sera toujours √©crit `[object ...]`, on peut encore affiner cela pour n'obtenir que le type en enlevant les 8 premiers caract√®res "[object " et le dernier "]" : 

```js
value = get("value.entree").thru(valeur => Object.prototype.toString.call(valeur).slice(8, -1))
// Entr√©e : "texte ‚Üí Sortie : "String"
// Entr√©e : true ‚Üí Sortie : "Boolean"
// Entr√©e : 42 ‚Üí Sortie : "Number"
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : "Object"
// Entr√©e : [1, 2, 3] ‚Üí Sortie : "Array"
// Entr√©e : null ‚Üí Sortie : "Null"
// Entr√©e qui n'existe pas ‚Üí Sortie : "Undefined"
```

üìå Ce script peut √™tre tr√®s utile pour s'assurer de l'homog√©n√©it√© des donn√©es que l'on traite.

---

## isString  

Teste si la valeur est une cha√Æne de caract√®res.  

```js
value = get("value.entree").isString()
// Entr√©e : ["texte"] ‚Üí Sortie : false
// Entr√©e : "texte" ‚Üí Sortie : true
```

## toString  

Convertit une valeur en cha√Æne de caract√®res.

```js
value = get("value.entree").toString()
// Entr√©e : 42 ‚Üí Sortie : "42"
```

> [!NOTE]  
> Toutes les fonctions de type *.toX* **prennent l'ensemble de la valeur donn√©e** (nombre, objet, tableau, tableau de tableaux‚Ä¶) et tentent de la convertir en **une seule valeur cible** 
> (string, number...), en utilisant les r√®gles de coercition de **JavaScript**.

Ce qui donne :  

```js
value = get("value.entree").toString()
// Entr√©e : [1, 2, 3] ‚Üí Sortie : "1,2,3"
// Entr√©e : [[1, 2], [3, 4]] ‚Üí Sortie : "1,2,3,4"
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : "[object Object]"
```

---

## isNumber  

V√©rifie si la valeur est un nombre.  

```js
value = get("value.entree").isNumber()
// Entr√©e : 42 ‚Üí Sortie : true
// Entr√©e : "42" ‚Üí Sortie : false
```

## toNumber  

Convertit une valeur en nombre.  

```js
value = get("value.entree").toNumber()
// Entr√©e : "42" ‚Üí Sortie : 42
// Entr√©e : "42, la r√©ponse √† tout, ou presque." ‚Üí Sortie : null (null dans Lodex, NaN pour not a number en JavaScript)
// Entr√©e : false ‚Üí Sortie : 0
// Entr√©e : true ‚Üí Sortie : 1
// Entr√©e : [42] ‚Üí Sortie : 42
// Entr√©e : [1, 2] ‚Üí Sortie : null
```

---

## isBoolean  

Teste si la valeur est un bool√©en.  

```js
value = get("value.entree").isBoolean()
// Entr√©e : true ‚Üí Sortie : true
// Entr√©e : "true" ‚Üí Sortie : false
```

> [!TIP] Il n'existe pas en **Lodash** de fonction qui transforme une valeur en un bool√©en. Pour faire ceci il faut utiliser la fonction **JavaScript** `Boolean`.
> Et pour pouvoir l'utiliser, il faut la passer dans une fonction **Lodash** comme `thru` ou `map` par exemple.
> ```js
> value = get("value.entree").thru(valeur => Boolean(valeur))
> // Entr√©e : 1 ‚Üí Sortie : true
> // Entr√©e : 0 ‚Üí Sortie : false
> // Entr√©e : "0" ‚Üí Sortie : true
> // Entr√©e : "texte" ‚Üí Sortie : true
> // Entr√©e : "" ‚Üí Sortie : false
> // Entr√©e : [1, 2] ‚Üí Sortie : true
> // Entr√©e : [] ‚Üí Sortie : false ‚ö†Ô∏è (un tableau, m√™me vide, est truthy)
> // Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : true
> // Entr√©e : {} ‚Üí Sortie : false ‚ö†Ô∏è (un objet, m√™me vide, est truthy)
> // Entr√©e : null ‚Üí Sortie : false
> ```

---

## isArray  

V√©rifie si la valeur est un tableau.  

```js
value = get("value.entree").isArray()
// Entr√©e : [1, 2, 3] ‚Üí Sortie : true
// Entr√©e : [] ‚Üí Sortie : true (un tableau, m√™me vide, est bien un tableau)
// Entr√©e : [[1, 2], [3, 4]] ‚Üí Sortie : true 
// Entr√©e : "texte" ‚Üí Sortie : false
// Entr√©e : true ‚Üí Sortie : false
// Entr√©e : 42 ‚Üí Sortie : false
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : false
// Entr√©e : null ‚Üí Sortie : false
```
## toArray  

Essaie de convertir la valeur en tableau, en fonction de son type :

- Une cha√Æne devient un tableau de caract√®res
- Un objet devient un tableau de ses valeurs
- Pour tout ce qui n‚Äôest pas tableau ou objet "it√©rable", on obtient [].

```js
value = get("value.entree").toArray()
// Entr√©e : "texte" ‚Üí Sortie : ["t", "e", "x", "t", "e"]
// Entr√©e : true ‚Üí Sortie : []
// Entr√©e : 42 ‚Üí Sortie : []
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : ["Einstein", "Physics"]
// Entr√©e : [1, 2, 3] ‚Üí Sortie : [1, 2, 3]
// Entr√©e : [] ‚Üí Sortie : []
// Entr√©e : null ‚Üí Sortie : []
```

## castArray  

A la diff√©rence de `toArray`, `castArray` encapsule une valeur dans un tableau, sans la transformer. 

```js
value = get("value.entree").castArray()
// Entr√©e : "texte" ‚Üí Sortie : ["texte"]
// Entr√©e : true ‚Üí Sortie : [true]
// Entr√©e : 42 ‚Üí Sortie : [42]
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : [{ "name": "Einstein", "field": "Physics" }]
// Entr√©e : [1, 2, 3] ‚Üí Sortie : [1, 2, 3]
// Entr√©e : [] ‚Üí Sortie : []
// Entr√©e : null ‚Üí Sortie : [null]
```

üëâ En r√©sum√© :  

`toArray` d√©coupe ou extrait selon le type.
`castArray` range tel quel dans un tableau.

---

## isObject  

Teste si la valeur est un objet.  

```js
value = get("value.entree").isObject()
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : true
// Entr√©e : [1, 2, 3] ‚Üí Sortie : true (un tableau est un objet, comme vu dans `typeof`)
// Entr√©e : "texte" ‚Üí Sortie : false
// Entr√©e : 42 ‚Üí Sortie : false
// Entr√©e : true ‚Üí Sortie : false
// Entr√©e : null ‚Üí Sortie : false (ici par contre, ***null*** n'est pas consid√©r√© comme objet ! `isObject` est une fonction **Lodash** et pas **JavaScript** )
```

---

## isEmpty  

V√©rifie si **le contenu** d'une valeur est vide.  

```js
value = get("value.entree").isEmpty()
// Entr√©e : [] ‚Üí Sortie : true
// Entr√©e : [1, 2, 3] ‚Üí Sortie : false
// Entr√©e : {} ‚Üí Sortie : true
// Entr√©e : { "name": "Einstein", "field": "Physics" } ‚Üí Sortie : false
// Entr√©e : "" ‚Üí Sortie : true
// Entr√©e : "texte" ‚Üí Sortie : false
// Entr√©e : null ‚Üí Sortie : true
// Entr√©e : undefined ‚Üí Sortie : true
// Entr√©e : 42 ‚Üí Sortie : true ‚ö†Ô∏è
// Entr√©e : 0 ‚Üí Sortie : true ‚ö†Ô∏è
```

> [!WARNING]
> On remarque que les deux derni√®res entr√©es, qui sont des nombres, renvoient *true*.
> Comme expliqu√©, `isEmpty` teste le contenu de ce qui lui est soumis.
> Dans un tableau, il v√©rifie qu'il contient bien des √©l√©ments.
> Dans un objet, il v√©rifie la pr√©sence de propri√©t√©s.
> Dans une cha√Æne, il regarde s'il y a des caract√®res.
> Pour tout le reste, bool√©ens, ***null***, ***undefined*** et nombres donc, il renvoie **true** car on consid√®re que ce ne sont pas des collections inspectables. Ces valeurs ne contiennent rien, elles sont donc consid√©r√©es comme vides.


> [!TIP]
> Si `isEmpty` permet de v√©rifier si le contenu d'une valeur est vide, il n'existe pas de fonction qui teste le contraire.
> Il faut alors inverser la fonction.
> ```js
> value = get("value.entree").thru(arr => !_.isEmpty(arr))
> // Entr√©e : [1, 2, 3] ‚Üí Sortie : true
> // Entr√©e : [] ‚Üí Sortie : false
> ```
> Attention √† bien interp√©ter le r√©sultat qui signifie litt√©ralement pour false "n'est pas non vide" lorsqu'on lit le code.
> On peut √©galement rendre plus lisible l'inversion du bool√©en qui ne se voit que par **!** en utilisant la fonction `negate` :
> ```js
> value = get("value.entree").thru(_.negate(_.isEmpty))
> // Entr√©e : [1, 2, 3] ‚Üí Sortie : true
> // Entr√©e : [] ‚Üí Sortie : false
> ```

Nous verrons dans les [cas d'usage](https://github.com/AnaelKremer/Atelier-Lodash-usage-Lodex/blob/main/10-cas-dusage.md) comment cr√©er une fonction que l'on nommerait `isFully` pour plus de clart√©.

---

## isEqual  

V√©rifie si deux valeurs sont **profond√©ment √©gales**.  

On a vu dans la partie sur les [op√©rateurs](https://github.com/AnaelKremer/Atelier-Lodash-usage-Lodex/blob/main/02-types-et-operateurs.md#les-op%C3%A9rateurs-javascript) que `===` servait √† tester une √©galit√© stricte. Par exemple :

```js
value = get("value.entree").thru(valeur=>valeur === 42 ? "Oui" : "Non")
// Entr√©e : 42 ‚Üí Sortie : "Oui"
```

**42** est un nombre, soit une valeur primitive.  
Pour les structures plus complexes comme les tableaux et objets, `===` ne fonctionnera plus.

```js
value = get("value.entree").thru(valeur=>valeur === [1, 2, 3] ? "Oui" : "Non")
// Entr√©e : [1, 2, 3] ‚Üí Sortie : false
```

Il faut utiliser `isEqual` qui compare r√©cursivement les tableaux et objets.

```js
value = get("value.entree").isEqual([1, 2, 3])
// Entr√©e : [1, 2, 3] ‚Üí Sortie : true
```

> [!TIP]
> Dans cet exemple, on a directement mis la valeur √† comparer en argument de la fonction ([1, 2, 3]).
> Dans Lodex, `isEqual` est particuli√®rement utile pour comparer les valeurs de 2 colonnes.
> Prennons des colonnes "entree" et "entree2", voici comment les comparer : 
> ```js
>  value = get("value.entree").isEqual(self.value.entree2)
> // "entree" : [1, 2, 3]
> // "entree2" : [1, 2, 3]
> // ‚Üí Sortie : true
> ``` 

---

## isEqualWith  

Comme `isEqual`, mais permet d‚Äôajouter un comparateur personnalis√©. Peut √™tre utile afin de d√©finir sa propre logique de comparaison ou de comparer avec une certaine tol√©rance.  

A titre d'exemple, on voudrait comparer si deux colonnes contiennent les m√™mes cha√Ænes, mais sans tenir compte de la casse (pour simplifier on se limite aux majuscules et minuscules).

```js
value = get("value.entree").isEqualWith( \
  self.value.entree2, \
  (a, b) => _.isString(a) && _.isString(b) && a.toLowerCase() === b.toLowerCase() \
)
// "entree" : "JavaScript"
// "entree2" : "JAVASCRIPT"
// ‚Üí Sortie : true
```

üëâ [Chapitre suivant](https://github.com/AnaelKremer/Atelier-Lodash-usage-Lodex/blob/main/09-autres-fonctions.md)
