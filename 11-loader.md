# Traitements avanc√©s dans un loader

## Qu‚Äôest-ce qu‚Äôun loader dans Lodex ?

Dans **Lodex**, un loader est un fichier de configuration permettant d'importer un jeu de donn√©es dans une instance.  

Son r√¥le est de convertir **un fichier brut** (CSV, JSON, XML, etc.) en un flux d‚Äôobjets **JavaScript** pr√™ts √† √™tre stock√©s dans **la base MongoDB de Lodex**.  

```mermaid
graph TD;
  A["Fichier brut (CSV, JSON, XML...)"] --> B["Loader (script EZS)"];
  B --> C["Objets JavaScript"];
  C --> D["Base MongoDB (Lodex)"];
```

Un loader s'√©crit dans un **fichier `.ini`**.  
- `.ini` = *Initialization file* (fichier d‚Äôinitialisation).  
- Historiquement, ce format sert √† d√©crire des configurations sous forme texte, avec des **sections** (`[ ]`) et des paires `cl√© = valeur`.  
- Lodex r√©utilise ce format pour d√©crire un **pipeline de transformation**.  

Un fichier `.ini` suit une logique d'√©tapes : il est lu de haut en bas et est ex√©cut√© s√©quentiellement.  
Chaque section √©tant une √©tape du pipeline qui applique une transformation au flux de donn√©es avant de le transmettre √† la suivante.  

üëâ Exemple :  

```ini
[assign]
path = Unpaywall
value = get("Identifiers.DOI")

[swing]
test = get("Unpaywall").isEmpty()
reverse = true

[swing/expand]
path = Unpaywall
size = 100

[swing/expand/URLConnect]
url = https://biblio-tools.services.istex.fr/v2/unpaywall/works/expand
timeout = 3600000
noerror = false
retries = 5
```

üîç Explications :

```txt
        [assign]    ‚Üí cr√©ation du champ "Unpaywall" √† partir du champ "DOI"
           ‚îÇ
           ‚ñº
        [swing]     ‚Üí On teste si le champ est vide (absence de DOI), si c'est le cas on exclue ces donn√©es du traitement
           ‚îÇ
           ‚ñº
     [swing/expand]     ‚Üí On regroupe les donn√©es par paquet de 100
           ‚îÇ
           ‚ñº
 [swing/expand/URLConnect]    ‚Üí On interroge l‚ÄôAPI Unpaywall
           ‚îÇ
           ‚ñº
 On r√©cup√®re les information d'Unpaywall dans notre champ
```

Ce mod√®le en **pipeline** rend les loaders tr√®s **flexibles** : on peut ajouter, retirer ou modifier des √©tapes sans casser l‚Äôensemble.  

---

Ecrire ses transformations dans un *loader* plut√¥t que dans **Lodex** en *enrichissements* pr√©sente plusieurs avantages :  

- Tout d'abord, **Lodex** fonctionne en **stream** :
  - Lorsqu‚Äôon applique des enrichissements, Lodex travaille par paquets.  
  - Chaque paquet est transform√©, envoy√© dans MongoDB, puis relu pour passer √† l‚Äô√©tape suivante.
  - Cela provoque de nombreux allers-retours entre Lodex et MongoDB, ce qui rallonge les temps de traitement.
- Un loader agit diff√©remment :
  - Le fichier est lu et transform√© √©tape par √©tape dans le pipeline EZS.  
  - Toutes les transformations sont effectu√©es **avant** l‚Äô√©criture en base.
  - Puis le flux final d‚Äôobjets JavaScript est envoy√© en une seule fois √† MongoDB.
- Et surtout, un loader permet de r√©aliser des op√©rations impossibles ou limit√©es dans Lodex:
  - **Lodex** traite chaque "notice" ind√©pendamment (*ou ligne par ligne)*.
  - Un loader peut lire et transformer tout le dataset √† la fois, ce qui rend possibles des op√©rations globales comme :
    - d√©doublonner des lignes enti√®res (*notices identiques*),
    - fusionner des donn√©es,
    - ou appliquer des transformations lourdes sur l‚Äôensemble.  

üìå **En r√©sum√©, Lodex traite les donn√©es ligne par ligne et nous pousse √† raisonner notice par notice, tandis qu‚Äôun loader permet de r√©fl√©chir en termes d‚Äôop√©rations globales sur l‚Äôensemble du dataset, ce qui en augmente consid√©rablement le potentiel de transformation.**

---

Pour qu'un loader fonctionne correctement, il faut inclure des instructions **EZS** sp√©cifiques (comme `[unpack]`, `[identify]`, `[OBJFlatten]`‚Ä¶) et d√©clarer des *plugins*, mais ce n'est pas l'objet de cette documentation.  

Ces aspects techniques rel√®vent davantage d‚Äôune formation d√©di√©e √† **EZS**, √ßa tombe bien ! Mon coll√®gue Fran√ßois Parmentier en a justement fait une [ici](https://github.com/parmentf/formation-ezs/tree/master).  

Nous allons nous concentrer ici sur un ensemble restreint d‚Äôinstructions essentielles pour transformer et nettoyer les donn√©es avec Lodash.  

## Les instructions EZS

### [assign]

`[assign]` permet d'affecter une valeur √† un champ de l'objet courant. Si le champ existe d√©j√†, sa valeur est √©cras√©e, sinon il est cr√©√©.

```json
[{
    "DO": "10.3390/info10050178 ",
    "TI": "Istex: A Database of Twenty Million Scientific Papers with a Mining Tool Which Uses Named Entities",
    "SO": "Information"
}]
```

```js
[assign]
path = doi
value = get("DO")
```

:point_down:

```json
[{
    "DO": "10.3390/info10050178 ",
    "TI": "Istex: A Database of Twenty Million Scientific Papers with a Mining Tool Which Uses Named Entities",
    "SO": "Information",
    "doi": "10.3390/info10050178 "
}]
```

Dans un `[assign]`, on peut cr√©er autant de nouveaux champs que l‚Äôon veut, tant qu‚Äôils s‚Äôappuient uniquement sur les champs existants du dataset original.  

On peut donc les d√©finir dans le m√™me bloc `[assign]`.

```js
[assign]
path = doi
value = get("DO")

path = normalizedTitle
value = get("TI").deburr().toLower()

path = normalizedSource
value = get("SO").deburr().toLower()
```

‚ö†Ô∏è Attention :  

Un champ cr√©√© dans un `[assign]` n‚Äôest pas utilisable imm√©diatement dans ce m√™me bloc.  
Il ne devient disponible qu‚Äô√† la sortie du bloc, c‚Äôest-√†-dire pour les instructions suivantes.  

Si l'on souhaite cr√©er un champ contenant le doi ou, s'il n'existe pas, le titre normalis√©, on ne peut ajouter ceci dans le bloc :

```js
path = doiOrNormalizedTitle
value = get("doi").thru(doi => _.isEmpty(doi) ? self.normalizedTitle : doi)
```

Il faut ouvrir un nouvel `[assign]`

```js
[assign]
path = doiOrNormalizedTitle
value = get("doi").thru(doi => _.isEmpty(doi) ? self.normalizedTitle : doi)
```

R√©sultat :

```json
[{
    "DO": "10.3390/info10050178 ",
    "TI": "Istex: A Database of Twenty Million Scientific Papers with a Mining Tool Which Uses Named Entities",
    "SO": "Information",
    "doi": "10.3390/info10050178 ",
    "normalizedTitle": "istex: a database of twenty million scientific papers with a mining tool which uses named entities",
    "normalizedSource": "information",
    "doiOrNormalizedTitle": "10.3390/info10050178 "
}]
```

üîë **√Ä retenir : `[assign]` permet d‚Äôajouter de nouveaux champs ou de modifier des champs existants (s‚Äôils portent le m√™me nom), tout en conservant l‚Äôobjet original.**  
**On enrichit donc ce dernier, au lieu de le remplacer.**

---

### [replace]

On a vu que l‚Äôon pouvait modifier des valeurs ou ajouter de nouveaux champs avec `[assign]`, ce qui permet d‚Äôenrichir l‚Äôobjet tout en conservant ses donn√©es originales.  

Mais il arrive qu‚Äôon trouve les noms de champs du dataset peu intelligibles (DO, TI, SO...) ou pas adapt√©s √† nos besoins. Plut√¥t que d'empiler des `[assign]` puis de supprimmer les champs originaux ensuite, il faut utiliser `[replace]` qui permet de reconstruire un objet en lieu et place de l'original.  

Ainsi : 

```js
[replace]
path = doi
value = get("DO")

path = normalizedTitle
value = get("TI").deburr().toLower()

path = normalizedSource
value = get("SO").deburr().toLower()
```

retourne :

```json
[{
    "doi": "10.3390/info10050178 ",
    "normalizedTitle": "istex: a database of twenty million scientific papers with a mining tool which uses named entities",
    "normalizedSource": "information"
}]
```

L‚Äôinstruction `[replace]` permet de **remplacer compl√®tement l‚Äôobjet courant** par un nouveau que l'on d√©finit dans le m√™me bloc.  

Si l‚Äôon veut cr√©er un champ suppl√©mentaire √† partir de l‚Äôobjet d√©j√† modifi√©, comme dans l'exemple d'`[assign]` avec *doiOrNormalizedTitle* attention au pi√®ge !

Il faudra ici ajouter `[assign]` pour cr√©er le champ *doiOrNormalizedTitle* et non pas `[replace]`.  

Si l'on ouvre un nouveau bloc `[replace]`, il va remplacer celui que l'on avait cr√©√© juste avant :

```js
[replace]
path = doi
value = get("DO")

path = normalizedTitle
value = get("TI").deburr().toLower()

path = normalizedSource
value = get("SO").deburr().toLower()

[replace]
path = doiOrNormalizedTitle
value = get("doi").thru(doi => _.isEmpty(doi) ? self.normalizedTitle : doi)
```

:point_down:

```json
[{
    "doiOrNormalizedTitle": "10.3390/info10050178 "
}]
```

`[replace]` n'est donc pas cumulatif comme l'est `[assign]`.

üîë **√Ä retenir : [replace] reconstruit un objet neuf en rempla√ßant compl√®tement l‚Äôobjet courant. Tous les champs non explicitement red√©finis disparaissent.**

---

### [exchange]
### [remove]
### [dedupe]
### [aggregate]

## ...

### D√©finir des fonctions r√©utilisables

On a d√©j√† vu qu'avec l'instruction `[ENV]` il √©tait possible de stocker un dictionnaire que l'on pouvait r√©utiliser.  

De la m√™me mani√®re, `[ENV]` peut contenir des **fonctions utilitaires**, que l'on d√©finit une fois et que l'on r√©utilise ensuite √† plusieurs endroits du pipeline.  

Par exemple, on a un jeu de donn√©es qui va contenir beaucoup de *bool√©ens* (is openacces, has repository, is retracted etc). Dans Lodex on souhaiterait afficher des "Oui" ou "Non" plut√¥t que les *bool√©ens*.  

On va d'abord √©cire notre fonction dans `[ENV]` et la nommer correctement (c'est souvent la partie la plus compliqu√©e).

```js
[env]
path = labelizeBoolean
value = fix((bool)=> bool === true ? "Oui" : bool === false ? "Non" : "Inconnu")
```

On utilise `fix` pour d√©clarer notre fonction, puis on √©crit une simple *ternaire*.  

Il suffit ensuite dans un `[assign]` de d√©clarer le champ que l'on veut transformer, puis d'appeler la *variable d'environnement* dans un `thru`.

```js
[assign]
path = value
value = get("isRetracted").thru(env("labelizeBoolean"))
// Entr√©e : true ‚Üí Sortie : "Oui"
```

Et si notre champ ne contient pas un seul, mais plusieurs *bool√©ens* dans un tableau, il suffit de remplacer `thru` par `map` !

```js
[assign]
path = value
value = get("isCnrs").map(env("labelizeBoolean"))
// Entr√©e :  [false, true, true, false] ‚Üí Sortie : ["Non","Oui","Oui","Non"]
```

Une fois cette logique acquise, on peut aller encore plus loin et se lancer dans **la composition de fonctions**.  

Plut√¥t que d‚Äô√©crire de longs traitements redondants, on cr√©e de petites briques sp√©cialis√©es (nettoyer une cha√Æne, nettoyer un tableau), puis on les encha√Æne et les combine pour construire des transformations plus complexes.  

---

A titre d'exemple, on souhaite "normaliser" les champs contenant des cha√Ænes de caract√®res (titre, r√©sum√©...). On souhaite √©galement r√©aliser ces op√©rations sur les √©l√©ments de certains tableaux comme les mots cl√©s. Et enfin on souhaite que donn√©es sous formes de tableaux soient d√©doublonn√©es, tri√©es et vid√©es de leurs valeurs falsy (null, ""...).  

On construit notre premi√®re brique : 

```js
[env]
path = normalizeString
value = fix((str)=> \
  _.toLower( \
    _.deburr( \
      _.trim(str) \
    ) \
  ) \
)
```

> [!NOTE]
> On le sait, utiliser `=>` nous fait passer dans du **JavaScript pur**.  
> Mais pour r√©aliser un cha√Ænage **Lodash** dans une fonction anonyme il convient de mettre le pr√©fixe `_` avant chaque fonction comme ici.  
> Mais lorsque l'on combine des fonctions, la lecture peut devenir difficile. Dans cet exemple, `trim` est d'abord utilis√©e, puis `deburr` et enfin `toLower`.
>
> Il existe une autre fa√ßon de d√©clarer un cha√Ænage, qui est sans doute plus lisible :
>
> Il faut placer la valeur √† transformer dans un **wrapper Lodash**. Litt√©ralement cela signifie que l'on *emballe* la valeur dans un objet sp√©cial afin de pouvoir la passer dans un pipeline de transformations.  
> Et comme vu [ici](https://github.com/AnaelKremer/Atelier-Lodash-usage-Lodex/blob/main/01-introduction.md#un-encha%C3%AEnement-de-fonctions-lodash) un pipeline **Lodash** doit commencer par `_.chain` et se conclure par `.value()`.

On peut donc √©crire notre premi√®re brique comme cela :

```js
[env]
path = normalizeString
value = fix((str)=> \
  _.chain(str) \
    .trim() \
    .deburr() \
    .toLower() \
    .value() \
)
```

Puis la tester sur une cha√Æne de caract√®res :

```js
[assign]
path = normalizedTitle
value = get("value.title").thru(env("normalizeString"))
// Entr√©e :  "Bibliom√©trie pr√™te √† l'emploi avec OpenAlex : retour d'exp√©rience" 
// ‚Üí Sortie : "bibliometrie prete a l'emploi avec openalex : retour d'experience"
```

On peut ensuite cr√©er notre deuxi√®me brique destin√©e √† traiter des tableaux (que l'on ajoute dans [ENV] en dessous de la premi√®re) :

```js
path = cleanArray
value = fix((arr) => \
  _.chain(arr) \
    .compact() \
    .uniq() \
    .sort() \
    .value() \
)
```

On peut enfin utiliser nos deux briques sur un m√™me champ :

```js
path = normalizedAllKeywords
value = get("value.authorsKeywords") \
    .concat(self.value.keywords) \
    .map(env("normalizeString")) \
    .thru(env("cleanArray"))
```

:point_down:

```json
{
  "authorsKeywords": [
    "bibliom√©trie",
    "openalex",
    "cnrs-inist",
    "retour d‚Äôexp√©rience"
  ],
  "keywords": [
    "bibliometrie",
    "OpenAlex",
    "CNRS-INIST",
    "exp√©rience utilisateur",
    "Lodex"
  ],
  "normalizedAllKeywords": [
    "bibliometrie",
    "cnrs-inist",
    "experience utilisateur",
    "lodex",
    "openalex",
    "retour d‚Äôexperience"
  ]
}
```